---
layout: post
title: Redis总结
category: component
tags: [component]
---

[java架构直通车-第7周 主从复制高可用Redis集群](https://class.imooc.com/sale/javaarchitect)  
[java架构直通车-第8周 Redis缓存雪崩，穿透](https://class.imooc.com/sale/javaarchitect)

## 推荐资料

## 1.Redis入门与基础
### 1-1 分布式架构概述 
- 分布式架构：不同业务子系统部署在不同服务器上；
    - 每个子系统可负责一个或多个业务
    - 子系统（服务）间可通信
    - 子系统可集群部署
    - 对用户透明

- 优点：
    - 业务解耦
    - 系统模块化，可复用化
    - 提高系统并发：因为业务请求被分散到不同服务器上 
  
- 缺点：
    - 架构复杂度增加
    - 调试复杂
    - 部署复杂
    - 子系统通信耗时、异常状况
    - 新人融入慢

- 设计原则
    - 异步解耦，mq
    - 幂等一致性
    - 拆分原则
    - 融合分布式中间件
    - 容错、高可用

### 1-2-3 什么是NoSql？ 
Nosql的全称是Not Only Sql，Nosql指的是非关系型数据库 

优点:
- 可扩展性：水平扩展，集群
- 高性能读取速度
- 存数据、做缓存、持久化
- 低成本
- 架构的灵活性，半结构化数据
- 没有复杂的关联关系

缺点:
- 没有标准化
- 有限的查询功能（到目前为止）
- 最终一致是不直观的程序

**NoSQL数据库的四大分类**  
- 键值(Key-Value)存储数据库   
相关产品： Redis、Memcache、Tokyo Cabinet/Tyrant、MecacheDB、Voldemort、Berkeley DB 、Dynamo    
典型应用： 内容缓存，主要用于处理大量数据的高访问负载。   
数据模型： 一系列键值对   
优势： 快速查询   
劣势： 存储的数据缺少   

- 结构化 列存储数据库    
相关产品：Cassandra, HBase, Riak 、LevelDB  
典型应用：分布式的文件系统   
数据模型：以列簇式存储，将同一列数据存在一起   
优势：查找速度快，可扩展性强，更容易进行分布式扩展   
劣势：功能相对局限  

- 文档型数据库    
相关产品：CouchDB、MongoDB 、SimpleDB  
典型应用：Web应用(与Key-Value类似，Value是结构化的)   
数据模型： 一系列键值对   
优势：数据结构要求不严格   
劣势： 查询性能不高，而且缺乏统一的查询语法  

- 图形(Graph)数据库    
相关数据库：Neo4J、InfoGrid、Infinite Graph  、flockDB 
典型应用：社交网络   
数据模型：图结构   
优势：利用图结构相关算法。   
劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。  

### 1-4 什么是分布式缓存，什么是Redis？ 为何引入Redis？ Redis使用场景？
1）分布式缓存：再分布式架构中（分布式服务器节点）使用的缓存技术，最著名的分布式缓存例子莫过于Memcached、 Redis
- 能有效地降低对后台服务器的压力
- 高性能的读取速度
- 进行分布式计算
- 跨服务器缓存
- 内存式缓存

2）[Redis](http://www.redis.cn/)：Redis是一种Key-Value键值型的内存数据库

**3）为何引入Redis**  
二八原则：80%是读操作
![](../../assets/images/2021/redis/yinru.png)

**4）Redis适用场景**  
[Redis应用场景](https://blog.csdn.net/hguisu/article/details/8836819)    
[redis常见应用场景](https://www.jianshu.com/p/40dbc78711c8)    
[Redis-使用场景](https://blog.csdn.net/sinat_27143551/article/details/80599170)    
- 缓存(数据查询、短连接、新闻内容、商品内容等等)。(最多使用) 代替memcached, 最新列表&排行榜，这里采用Redis的List数据结构或sorted set结构,方便实现最新列表or排行榜 等业务场景。
    - 商品列表
    - 收藏列表
    - 好友列表
    - 评论列表
    - @提示列表
- 分布式集群架构中的session分离。 
- 任务队列。(秒杀、抢购、12306等等) 
- 消息队列
- 应用排行榜。 
- 网站访问统计。 
- 数据过期处理(可以精确到毫秒)：**登录验证码，短信验证码**
- 聊天室的在线好友列表。 
- 存储社交关系  
譬如将用戶的好友/粉丝/关注，可以存在一个sortedset中，score可以是timestamp，这样求两个人的共同好友的操作，可能就只需要用求交集命令即可 
- 各种计数，商品维度计数和用户维度计数  
Redis的命令都是原子性的，你可以轻松地利用INCR，DECR等命令来计数。  
商品维度计数（喜欢数，评论数，鉴定数，浏览数,etc）  
用户维度计数（动态数、关注数、粉丝数、喜欢商品数、发帖数 等）

### 1-5 分布式缓存方案与技术选型对比：Redis VS Memcache VS Ehcache 
https://www.cnblogs.com/qlqwjy/p/7788912.html  
**Redis**  
Redis是一个开源的使用ANSIC语言编写、支持网络、可基于内存亦可持久化的日志型、高性能的Key-Value数据库
- 优点  
    - 内存数据库：性能极高 – Redis能支持超过 100K+ 每秒的读写频率。
    - 单进程单线程，线程安全
    - 采用 IO 多路复用机制，非阻塞IO(epoll)
    - 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
    - 可持久化
    - 支持分布式、集群、主从同步等
    - 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。
    - 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
    - 发布订阅

- 缺点
    - 数据库容量受到物理内存的限制
    - 单进程单线
    
**Ehcache**  
是一个纯Java的进程内缓存框架,具有快速、精干等特点,是Hibernate中默认CacheProvider。

- 特性：  
    - 1.快速、简单：基于JVM      
    - 2.多种缓存策略      
    - 3.缓存数据有两级：内存和磁盘，因此无需担心容量问题      
    - 4.缓存数据会在虚拟机重启的过程中写入磁盘      
    - 5.可以通过RMI、可插入API等方式进行分布式缓存      
    - 6.具有缓存和缓存管理器的侦听接口  
    - 7.支持多缓存管理器实例，以及一个实例的多个缓存区域      
    - 8.提供Hibernate的缓存实现 

- 缺点：      
    - 集群、分布式架构下 不支持

**Memcached**    
基于一个存储键/值对的hashmap。其守护进程（daemon）是用C写的，但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信  
- 特点：   
    - 内存数据库：性能极高 
    - 简单的key-value存储  
    - 内存使用率高  
    - 数据类型简单  
    - 多核处理，多线程  

- 缺点：  
    - 无法持久化，无法容灾  
    - 数据类型单一：String

### 1-6-7 安装与配置Redis 
Linux环境[安装](https://blog.csdn.net/yuanlong122716/article/details/104347670)  
```
1. 下载：
访问 https://redis.io/download  到官网进行下载  
或者 wget https://download.redis.io/releases/redis-3.x.x.tar.gz

2.解压
##/opt/redis为举例的安装目录.
mkdir /opt/redis
tar ‐zxvf redis‐3.x.x.tar.gz ‐C /opt/redis

3.编译
# 安装依赖
yum install gcc-c++
#切入目录
cd /opt/redis/redis‐3.x.x 
#编译
make 
#安装
make install
// 备注：// make test you need tcl8.5 or newer   需要安装tcl
下载tcl8.6.0: 
进入unix, 
执行./configure,
生成Makefile, 
执行make
执行make install
安装tcl后, make test 报错, 修改tests/integration/replication-psync.tcl文件,修改after后的100->500

4.移动可执行文件至bin目录
mkdir /opt/redis/redis‐3.x.x/bin
回车
mv redis‐trib.rb redis‐server redis‐sentinel redis‐cli redis‐check‐dump redis‐check‐aof redis‐
benchmark mkreleasehdr.sh /opt/redis/redis‐3.x.x/bin
回车

5.移动配置文件到bin目录
mkdir /opt/redis/redis‐3.x.x/bin
mv /opt/redis/redis‐3.x.x/redis.conf /opt/redis/redis‐3.x.x/bin

6.修改配置文件
vim /opt/redis/redis‐3.x.x/bin/redis.conf
/requirepass  #搜索密码, 释放注释, 修改密码
bind 127.0.0.1   #注释掉
daemonize yes  #守护进程：前台运行、后台运行
dir ./  修改为 dir/usr/local/reids/work  #持久化目录

7.启动服务
cd /opt/redis/redis‐3.x.x/bin
./redis‐server redis.conf

8.测试启动是否成功：如果运行以下命令后出现：Could not connect to Redis at xxxx: Connection refused. 则说明启动不成功；如果进入了redis交互页面，则说明启动成功了。
cd /opt/redis/redis‐3.x.x/bin
./redis‐cli ‐p %port端口号% ‐a %requirepass设置的密码%  //redis-cli -h 127.0.0.1 -p 6379 -a 123456

9.设置开机自启动
进入redis/utils目录
复制文件：cp redis_int_script /ect/int.d/
执行 vim redis_int_script 添加
#chkconfig: 22345 10 90
#description: Start and Stop redis
执行 chkconfig redis_int_script on 注册
```
windows环境[安装](https://blog.csdn.net/antma/article/details/79225084)  
Redis项目不正式支持Windows。但是，微软开发并维护了针对Win64的Windows版本。    
下载地址：https://github.com/tporadowski/redis/releases。    
Windows版本下载地址：https://github.com/MicrosoftArchive/redis/releases    
安装：https://www.cnblogs.com/skmobi/p/11696620.html    
```
1.下载

2.解压

3.启动：打开cmd命令进入redis目录，
执行  E:\redis>redis-server.exe redis.windows.conf

4.链接：启动后窗口不要关，新开一个cmd窗口
执行 E:\redis>redis-cli ==>默认连接本机127.0.0.1 端口号 6379，连接成功。

5、将Redis 加入 Windows 服务，执行
redis-server --service-install redis.windows.conf
提示：Redis successfully installed as a service. 表示加入服务成功！
如果 Redis 设置了密码，加入服务时会提示: Granting read/write access to 'NT AUTHORITY\NetworkService' on: "E:\redis" "E:\redis\"

可以服务列表redis的属性里加启动参数：-a 123456
```

### 1-8-9 Redis命令行客户端redis-cli基本使用 
- redis-cli -a password shutdown ：关闭redis
- ./redis_init_script stop ：关闭redis
- redis-cli ：进入到redis客户端
- auth pwd ：输入密码
- set key value ：设置缓存
- get key ：获得缓存
- del key ：删除缓存
- redis-cli -a password ping ：查看是否存活
- SETNX：是「SET if Not eXists」的缩写，就是只有key不存在时才设置值，可以防止覆盖数据
用途：用来实现分布式锁
- keys *：查看所有的key (不建议在生产上使用，有性能影响)
- type key：key的类型

### 1-10-11 Redis的数据类型 - string 
String(最大512M)：Value 不仅是 String，也可以是数字

- set key value [ex 秒数] [px 毫秒数] [nx/xx]
 　　如果ex和px同时写，则以后面的有效期为准  
 　　nx：如果key不存在则建立  
 　　xx：如果key存在则修改其值
- setnx rekey data：设置已经存在的key，不会覆盖
- get/set/del：查询/设置/删除
- mset key1 value1 key2 value2 一次设置多个值
- mget key1 key2 ：一次获取多个值
- msetnx：连续设置，如果存在则不设置
- setrange key offset value：把字符串的offset偏移字节改成value  如果偏移量 > 字符串长度，该字符自动补0x00
- getrange key start end：截取数据，end=-1 代表到最后
- setrange key start newdata：从start位置开始替换数据
- append key value ：把value追加到key 的原值上
- decrby key num：累减给定数值
- getrange key start stop：获取字符串中[start,stop]范围的值，下标，左数从0开始，右数从-1开始  
　　注意：当start>length，则返回空字符串，当stop>=length，则截取至字符串尾，如果start所处位置在stop右边，则返回空字符串
- getset key nrevalue：获取并返回旧值，在设置新值
- incr key：自增1，返回新值，如果incr一个不是int的value则返回错误，incr一个不存在的key，则设置key为1
- decr key：类减1
- incrby key 2：跳2自增
- incrbyfloat by 0.7： 自增浮点数
- setbit key offset value：设置offset对应二进制上的值，返回该位上的旧值  
　　注意：如果offset过大，则会在中间填充0 , offset最大到多少：　2^32-1，即可推出最大的字符串为512M
- bitop operation destkey key1 [key2..]对key1、key2做opecation并将结果保存在destkey上  
　　opecation可以是AND OR NOT XOR  
- strlen key：取指定key的value值的长度
- setex key time value：设置key对应的值value，并设置有效期为time秒

### 1-12-13 Redis的数据类型 - hash 
Hash：Hash 是一个 String 的 Key 和 Value 的映射表，Hash 特别适合存储对象。常用命令：hget，hset，hgetall 等  
hash：类似map，存储结构化数据结构，比如存储一个对象（不能有嵌套对象）  
Redis hash 是一个string类型的field和value的映射表，它的添加、删除操作都是O(1)（平均）。hash特别适用于存储对象，将一个对象存储在hash类型中会占用更少的内存，并且可以方便的存取整个对象。  
配置： hash_max_zipmap_entries 64 #配置字段最多64个  
　　　hash_max_zipmap_value 512 #配置value最大为512字节
- （1）hset myhash field value：设置myhash的field为value,例如  "hset user name imooc"-> 创建一个user对象，这个对象中包含name属性，name值为imooc
- （2）hsetnx myhash field value：不存在的情况下设置myhash的field为value
- （3）hmset myhash field1 value1 field2 value2：同时设置多个field-> hset user age 18 phone 139123123
- （4）hget myhash field：获取指定的hash field
- （5）hmget myhash field1 field2：一次获取多个field
- （6）hincrby user age 2：累加属性
- hincrbyfloat user age 2.2：累加属性
- （7）hexists user age：判断属性是否存在
- （8）hlen myhash：返回hash的field数量
- （9）hdel myhash field：删除指定的field
- （10）hkeys myhash：返回hash所有的field
- （11）hvals myhash：返回hash所有的value
- hdel user：删除对象
- （12）hgetall myhash：获取某个hash中全部的field及value：hgetall user：获得整个对象user的内容

### 1-14-15 Redis的数据类型 - list 
List ：双向链表实现，常用命令：lpush、rpush、lpop、rpop、lrange（获取列表片段）等

### 1-16 Redis的数据类型 - set 
Set ：String 类型的无序、去重集合。集合是通过 hashtable 实现的。常用命令：sdd、spop、smembers、sunion

### 1-17-18 Redis的数据类型 - zset 
Zset ：有序的并且不重复的集合，常用命令：zadd、zrange、zrem、zcard 等。

## 2.SpringBoot整合Redis实战
Jedis 是 Redis 官方首选的 Java 客户端开发包  
Redisson  
集成 spring-boot-starter-data-redis使用RedisTemplate：封装Jedis操作   
可视化工具redis-desktop-manager 

### 2-0 聊一聊多路复用器，阻塞和非阻塞 

### 2-1 Redis 架构单线程模型原理解析 

### 2-2-3 SpringBoot整合Redis实战 

### 2-4 Redis 操作工具类讲解 


## 3.Redis进阶提升与主从复制   

### 3-1 Redis 的发布（pub）与订阅（sub） 

### 3-2-3 Redis的持久化机制 - RDB  
- RDB(redis-database)
    - 内存快照-dump.rdb
    - 恢复快、效率高、非实时存在丢数据风险
- AOF(append-only-file)
    - 日志文件追加记录
    - 实时持久化、安全、文件大恢复效率低
- 4.0-AOF/RDB混合持久化模式

### 3-4-5 Redis的持久化机制 - AOF 


### 3-6 Redis 主从复制原理解析 

### 3-7 多虚拟机克隆方案 

### 3-8 搭建Redis主从复制Master-slave（读写分离） 

### 3-9 Redis无磁盘化复制原理解析 

### 3-10-11 Redis 缓存过期处理与内存淘汰机制 
内存淘汰[回收机制](https://blog.csdn.net/yuanlong122716/article/details/104420880)
- 设置超期: 最近最少使用、即将超期、随机
- 未设置超期: 最近最少使用、随机
- 不淘汰

过期[删除策略](https://blog.csdn.net/yuanlong122716/article/details/104420880)
- 定期删除：每过段时间检查一次redis，删除里面过期键
- 惰性删除：每次取时检查是否过期需要删除
- 定时删除：设置超期时设置定时器


## 4.Redis 哨兵机制与实现
监控、提醒、自动故障转移  
Redis哨兵架构及数据丢失问题分析
### 4-1 Redis 的哨兵模式 

### 4-2 Redis 哨兵机制与实现 - 1  

### 4-3 Redis 哨兵机制与实现 - 2 

### 4-4 解决原Master恢复后不同步问题 

### 4-5 图解哨兵 

### 4-6 附：哨兵信息检查 

### 4-7-8 SpringBoot 集成Redis哨兵 -配置 

### 补充：redis实现分布式锁
[Redis实现分布式锁](https://blog.csdn.net/yuanlong122716/article/details/104366372)  
[Redis分布式锁的Java实现（基于Lua脚本）](https://blog.csdn.net/yuanlong122716/article/details/104366469)

## 5.Redis集群
- 3.0-redis-cluster: Redis Custer数据分布式算法-Hash slot
- twemproxy
- codis

### 5-1-2 Redis-Cluster 集群 与环境准备 

### 5-3-4 搭建Redis的三主三从集群模式 


### 5-5 什么是slot槽节点 

### 5-6 Springboot集成Redis集群


##  6.Redis缓存雪崩、击穿、穿透、一致性等常见问题与批量查询的优化设计 
缓存[雪崩、击穿、穿透、一致性等常见问题](https://blog.csdn.net/yuanlong122716/article/details/104383926)
### 6-1 缓存穿透的解决方案 

### 6-2 缓存穿透之布隆过滤器 

### 6-3 布隆过滤器基本思想 

### 6-4 使用布隆过滤器 

### 6-5 缓存雪崩与预防 
**1).缓存雪崩**：缓存全失效、过期、缓存服务器故障->请求全查库  
解决方案：  
- 缓存reload机制、提前更新缓存、设置过期时间尽量随机分散  
- 主从或集群，提供备用缓存服务  
- 后台限流降级、加锁或队列控制读写
**2).缓存穿透**：查一个不存在的数据，缓存中无，库中无，所以不会更新到缓存中，每次都会查库    
解决方案：[布隆过滤器](https://blog.csdn.net/yuanlong122716/article/details/104402602)，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉

**3).缓存击穿**：数据存在，但在redis中已过期，此时大量并发请求都会从DB加载数据并回设到缓存    
解决方案：使用互斥锁(mutex key)，在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法

**4).缓存一致性问题**: 先写库再更缓存、或者先更缓存再写库，都可能出现异常导致数据不一致问题

### 6-6 multiGet 批量查询优化 

### 6-7 pipeline 批量查询优化  

### 6-10 可能会遇到的面试题

### 如何保证Redis缓存和数据库的[双写一致性](https://blog.csdn.net/yuanlong122716/article/details/104444315)


-- ----------------------------------------
## 附：redis命令
### key pattern 查询相应的key
- （1）redis允许模糊查询key　　有3个通配符  *、?、[]
- （2）randomkey：返回随机key
- （3）type key：返回key存储的类型
- （4）exists key：判断某个key是否存在  
	举例：exists 00c11b4e-7cc8-496b-b5b4-27134a8f08a0  
	返回1 存在 返回0不存在
- （5）del key：删除key
- （6）rename key newkey：改名
- （7）renamenx key newkey：如果newkey不存在则修改成功
- （8）move key 1：将key移动到1数据库
- （9）ttl key：查询key的生命周期（秒）
- （10）expire key 整数值：设置key的生命周期以秒为单位
- （11）pexpire key 整数值：设置key的生命周期以毫秒为单位
- （12）pttl key：查询key 的生命周期（毫秒）
- （13）perisist key：把指定key设置为永久有效


### 链表list操作
Redis的list类型其实就是一个每个子元素都是string类型的双向链表，链表的最大长度是2^32。list既可以用做栈，也可以用做队列。  
list的pop操作还有阻塞版本，主要是为了避免轮询
- （1）lpush key value：把值插入到链表头部
- （2）rpush key value：把值插入到链表尾部
- （3）lpop key ：返回并删除链表头部元素
- （4）rpop key： 返回并删除链表尾部元素
- （5）lrange key start stop：返回链表中[start, stop]中的元素
- （6）lrem key count value：从链表中删除value值，删除count的绝对值个value后结束
　  ，count > 0 从表头删除　　count < 0 从表尾删除　　count=0 全部删除
- （7）ltrim key start stop：剪切key对应的链接，切[start, stop]一段并把改制重新赋给key
- （8）lindex key index：返回index索引上的值
- （9）llen key：计算链表的元素个数
- （10）linsert key after|before search value：在key 链表中寻找search，并在search值之前|之后插入value
- （11）rpoplpush source dest：把source 的末尾拿出，放到dest头部，并返回单元值
  应用场景： task + bak 双链表完成安全队列  
　业务逻辑： rpoplpush task bak接收返回值并做业务处理，如果成功则rpop bak清除任务，如果不成功，下次从bak表取任务
- （12）brpop，blpop key timeout：等待弹出key的尾/头元素  
timeout为等待超时时间，如果timeout为0则一直等待下去，应用场景：长轮询ajax，在线聊天时能用到

### 集合set结构操作
特点：无序性、确定性、唯一性
- （1）sadd key value1 value2：往集合里面添加元素
- （2）smembers key：获取集合所有的元素
- （3）srem key value：删除集合某个元素
- （4）spop key：返回并删除集合中1个随机元素（可以坐抽奖，不会重复抽到某人）
- （5）srandmember key：随机取一个元素
- （6）sismember key value：判断集合是否有某个值
- （7）scard key：返回集合元素的个数
- （8）smove source dest value：把source的value移动到dest集合中
- （9）sinter key1 key2 key3：求key1 key2 key3的交集
- （10）sunion key1 key2：求key1 key2 的并集
- （11）sdiff key1 key2：求key1 key2的差集
- （12）sinterstore res key1 key2：求key1 key2的交集并存在res里

### 有序集合zset
概念：它是在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动按新的值调整顺序。可以理解为有两列的mysql表，一列存储value，一列存储顺序，操作中key理解为zset的名字。

和set一样sorted，sets也是string类型元素的集合，不同的是每个元素都会关联一个double型的score。sorted set的实现是skip list和hash table的混合体。

当元素被添加到集合中时，一个元素到score的映射被添加到hash table中，所以给定一个元素获取score的开销是O(1)。另一个score到元素的映射被添加的skip list，并按照score排序，所以就可以有序地获取集合中的元素。添加、删除操作开销都是O(logN)和skip list的开销一致，redis的skip list 实现是双向链表，这样就可以逆序从尾部去元素。sorted set最经常使用方式应该就是作为索引来使用，我们可以把要排序的字段作为score存储，对象的ID当元素存储。  
- （1）zadd key score1 value1：添加元素
- （2）zrange key start stop [withscore]：把集合排序后,返回名次[start,stop]的元素  默认是升续排列  withscores 是把score也打印出来
- （3）zrank key member：查询member的排名（升序0名开始）
- （4）zrangebyscore key min max [withscores] limit offset N：集合（升序）排序后取score在[min, max]内的元素，并跳过offset个，取出N个
- （5）zrevrank key member：查询member排名（降序 0名开始）
- （6）zremrangebyscore key min max：按照score来删除元素，删除score在[min, max]之间
- （7）zrem key value1 value2：删除集合中的元素
- （8）zremrangebyrank key start end：按排名删除元素，删除名次在[start, end]之间的
- （9）zcard key：返回集合元素的个数
- （10）zcount key min max：返回[min, max]区间内元素数量
- （11）zinterstore dest numkeys key1[key2..] [WEIGHTS weight1 [weight2...]] [AGGREGATE 


```
SUM|MIN|MAX]  
求key1，key2的交集，key1，key2的权值分别是weight1，weight2  
聚合方法用 sum|min|max  
聚合结果 保存子dest集合内  
注意：weights,aggregate如何理解？  
答：如果有交集，交集元素又有score，score怎么处理？aggregate num->score相加，min最小score，max最大score，另外可以通过weights设置不同的key的权重，交集时  score*weight
```

### 服务器相关命令
禁用：flushall 清空整个 Redis 服务器的数据(删除所有数据库的所有 key )
- select index：切换数据库，总共默认16个
- （1）ping：测定连接是否存活
- （2）echo：在命令行打印一些内容
- （3）select：选择数据库
- （4）quit：退出连接
- （5）dbsize：返回当前数据库中key的数目
- （6）info：获取服务器的信息和统计
- （7）monitor：实时转储收到的请求
- （8）config get 配置项：获取服务器配置的信息  
　　config set 配置项  值：设置配置项信息
- （9）flushdb：删除当前选择数据库中所有的key
- （10）flushall：删除所有数据库中的所有的key
- （11）time：显示服务器时间，时间戳（秒），微秒数
- （12）bgrewriteaof：后台保存rdb快照
- （13）bgsave：后台保存rdb快照
- （14）save：保存rdb快照
- （15）lastsave：上次保存时间
- （16）shutdown [save/nosave]  
注意：如果不小心运行了flushall，立即shutdown nosave，关闭服务器，然后手工编辑aof文件，去掉文件中的flushall相关行，然后开启服务器，就可以倒回原来是数据。如果flushall之后，系统恰好bgwriteaof了，那么aof就清空了，数据丢失。  
- （17）showlog：显示慢查询    
问：多慢才叫慢？    
答：由slowlog-log-slower-than 10000，来指定（单位为微秒）    
问：服务器存储多少条慢查询记录    
答：由slowlog-max-len 128，来做限制   
 












